<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Openwsman::EndPointReference - Openwsman - WS-Management for all</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-i-add_selector">#add_selector</a>
    
    <li ><a href="#method-i-classname">#classname</a>
    
    <li ><a href="#method-i-clone">#clone</a>
    
    <li ><a href="#method-i-cmp">#cmp</a>
    
    <li ><a href="#method-i-each">#each</a>
    
    <li ><a href="#method-i-namespace">#namespace</a>
    
    <li ><a href="#method-i-prefix">#prefix</a>
    
    <li ><a href="#method-i-resource_uri">#resource_uri</a>
    
    <li ><a href="#method-i-selector">#selector</a>
    
    <li ><a href="#method-i-selector_count">#selector_count</a>
    
    <li ><a href="#method-i-selector_names">#selector_names</a>
    
    <li ><a href="#method-i-serialize">#serialize</a>
    
    <li ><a href="#method-i-to_s">#to_s</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Openwsman::EndPointReference">
  <h1 id="class-Openwsman::EndPointReference" class="class">
    class Openwsman::EndPointReference
  </h1>

  <section class="description">
    
<p>The <a href="EndPointReference.html">EndPointReference</a> is a stub to
proxy server-side operations</p>

<p>Each WS-Management operation (Get, Enumerate, Invoke, …) has an associated
end point reference, providing the actual implementation of the operation.</p>

<p><a href="EndPointReference.html">EndPointReference</a></p>

  </section>

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-add_selector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">add_selector</span><span
            class="method-args">(p1, p2)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Add selector as key/value pair</p>
          
          

          
          <div class="method-source-code" id="add_selector-source">
            <pre>void add_selector(const char *name, const char *text) {
    epr_add_selector_text($self, name, text);
  }

  /*
   * Serialization
   *
   * XML-serialize EndPointReference as child (with namespace and name) of node
   *
   */
  int serialize( WsXmlNodeH node, const char *ns, const char *epr_node_name, int embedded) {
    return epr_serialize(node, ns, epr_node_name, $self, embedded);
  }
  

  %alias cmp &quot;==&quot;;
  %typemap(out) int cmp
    &quot;$result = ($1 == 0) ? Qtrue : Qfalse;&quot;;

  /*
   * Compare two EndPointReferences
   *
   */
  int cmp(const epr_t *epr2) {
    return epr_cmp($self, epr2);
  }
  
  /*
   * String representation (XML syntax)
   *
   */
  char *to_xml( const char *ns = NULL, const char *epr_node_name = NULL) {
    return epr_to_txt($self, ns?ns:XML_NS_ADDRESSING, epr_node_name?epr_node_name:WSA_EPR);
  }



  %rename(&quot;to_s&quot;) string();

  %newobject string;
  /*
   * String representation (&lt;uri&gt;?&lt;selector&gt;,&lt;selector&gt;,...)
   *
   */
  char *string() {
    return epr_to_string($self);
  }

  /*
   * Number of selectors
   */
  int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-classname" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">classname</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Classname of EPR</p>
          
          

          
          <div class="method-source-code" id="classname-source">
            <pre>char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">clone</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>clone the <a href="EndPointReference.html">EndPointReference</a> instance</p>
          
          

          
          <div class="method-source-code" id="clone-source">
            <pre>epr_t *clone(const epr_t *epr) {
    return epr_copy(epr);
  }


  /*
   * Add selector as key/value pair
   *
   */
  void add_selector(const char *name, const char *text) {
    epr_add_selector_text($self, name, text);
  }

  /*
   * Serialization
   *
   * XML-serialize EndPointReference as child (with namespace and name) of node
   *
   */
  int serialize( WsXmlNodeH node, const char *ns, const char *epr_node_name, int embedded) {
    return epr_serialize(node, ns, epr_node_name, $self, embedded);
  }
  

  %alias cmp &quot;==&quot;;
  %typemap(out) int cmp
    &quot;$result = ($1 == 0) ? Qtrue : Qfalse;&quot;;

  /*
   * Compare two EndPointReferences
   *
   */
  int cmp(const epr_t *epr2) {
    return epr_cmp($self, epr2);
  }
  
  /*
   * String representation (XML syntax)
   *
   */
  char *to_xml( const char *ns = NULL, const char *epr_node_name = NULL) {
    return epr_to_txt($self, ns?ns:XML_NS_ADDRESSING, epr_node_name?epr_node_name:WSA_EPR);
  }



  %rename(&quot;to_s&quot;) string();

  %newobject string;
  /*
   * String representation (&lt;uri&gt;?&lt;selector&gt;,&lt;selector&gt;,...)
   *
   */
  char *string() {
    return epr_to_string($self);
  }

  /*
   * Number of selectors
   */
  int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cmp" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">cmp</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Compare two EndPointReferences</p>
          
          

          
          <div class="method-source-code" id="cmp-source">
            <pre>int cmp(const epr_t *epr2) {
    return epr_cmp($self, epr2);
  }
  
  /*
   * String representation (XML syntax)
   *
   */
  char *to_xml( const char *ns = NULL, const char *epr_node_name = NULL) {
    return epr_to_txt($self, ns?ns:XML_NS_ADDRESSING, epr_node_name?epr_node_name:WSA_EPR);
  }



  %rename(&quot;to_s&quot;) string();

  %newobject string;
  /*
   * String representation (&lt;uri&gt;?&lt;selector&gt;,&lt;selector&gt;,...)
   *
   */
  char *string() {
    return epr_to_string($self);
  }

  /*
   * Number of selectors
   */
  int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-each" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            each { |key,value| ... }
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>enumerate over selectors as key,value pairs</p>
          
          

          
          <div class="method-source-code" id="each-source">
            <pre>void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-namespace" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">namespace</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Namespace of EPR</p>
          
          

          
          <div class="method-source-code" id="namespace-source">
            <pre>char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-prefix" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">prefix</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Prefix of EPR</p>
          
          

          
          <div class="method-source-code" id="prefix-source">
            <pre>char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resource_uri" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resource_uri</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>The resource URI associated to this <a
href="EndPointReference.html">EndPointReference</a></p>
          
          

          
          <div class="method-source-code" id="resource_uri-source">
            <pre>char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-selector" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">selector</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Get value of selector by name epr#selector converts any value passed to
String</p>

<h4 id="method-i-selector-label-Shortcut">Shortcut<span><a href="#method-i-selector-label-Shortcut">&para;</a> <a href="#top">&uarr;</a></span></h4>

<p>epr.selector(“name”) can also be abbreviated as epr.name</p>

<h4 id="method-i-selector-label-Examples">Examples<span><a href="#method-i-selector-label-Examples">&para;</a> <a href="#top">&uarr;</a></span></h4>

<pre class="ruby"><span class="ruby-identifier">epr</span>.<span class="ruby-identifier">selector</span>(<span class="ruby-string">&quot;name&quot;</span>)
<span class="ruby-identifier">epr</span>.<span class="ruby-identifier">selector</span>(<span class="ruby-identifier">value</span>)
<span class="ruby-identifier">epr</span>.<span class="ruby-identifier">name</span>
</pre>
          
          

          
          <div class="method-source-code" id="selector-source">
            <pre>char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-selector_count" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">selector_count</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Number of selectors</p>
          
          

          
          <div class="method-source-code" id="selector_count-source">
            <pre>int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-selector_names" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">selector_names</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Return list of selector names</p>
          
          

          
          <div class="method-source-code" id="selector_names-source">
            <pre>VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-serialize" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">serialize</span><span
            class="method-args">(p1, p2, p3, p4)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>Serialization</p>

<p>XML-serialize <a href="EndPointReference.html">EndPointReference</a> as
child (with namespace and name) of node</p>
          
          

          
          <div class="method-source-code" id="serialize-source">
            <pre>int serialize( WsXmlNodeH node, const char *ns, const char *epr_node_name, int embedded) {
    return epr_serialize(node, ns, epr_node_name, $self, embedded);
  }
  

  %alias cmp &quot;==&quot;;
  %typemap(out) int cmp
    &quot;$result = ($1 == 0) ? Qtrue : Qfalse;&quot;;

  /*
   * Compare two EndPointReferences
   *
   */
  int cmp(const epr_t *epr2) {
    return epr_cmp($self, epr2);
  }
  
  /*
   * String representation (XML syntax)
   *
   */
  char *to_xml( const char *ns = NULL, const char *epr_node_name = NULL) {
    return epr_to_txt($self, ns?ns:XML_NS_ADDRESSING, epr_node_name?epr_node_name:WSA_EPR);
  }



  %rename(&quot;to_s&quot;) string();

  %newobject string;
  /*
   * String representation (&lt;uri&gt;?&lt;selector&gt;,&lt;selector&gt;,...)
   *
   */
  char *string() {
    return epr_to_string($self);
  }

  /*
   * Number of selectors
   */
  int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-to_s" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">to_s</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>String representation (&lt;uri&gt;?&lt;selector&gt;,&lt;selector&gt;,…)</p>
          
          

          
          <div class="method-source-code" id="to_s-source">
            <pre>char *string() {
    return epr_to_string($self);
  }

  /*
   * Number of selectors
   */
  int selector_count(void) {
    return epr_selector_count($self);
  }

  /*
   * The resource URI associated to this EndPointReference
   *
   */
  char *resource_uri(void) {
    return epr_get_resource_uri($self);
  }
  

  /*
   * Get value of selector by name
   * epr#selector converts any value passed to String
   *
   * ==== Shortcut
   * epr.selector(&quot;name&quot;) can also be abbreviated as epr.name
   *
   * ==== Examples
   *   epr.selector(&quot;name&quot;)
   *   epr.selector(value)
   *   epr.name
   */
  char *selector(VALUE v) {
    const char *name = as_string(v);

    return wsman_epr_selector_by_name($self, name);
  }

#if !defined(SWIGJAVA) /* Target_* undefined for Java in openwsman.i */
  /*
   * Return list of selector names
   */

  VALUE selector_names(void) {



    int i;
    Target_Type ary = Target_SizedArray($self-&gt;refparams.selectorset.count);
    key_value_t *p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      Target_ListSet(ary, i, SWIG_FromCharPtr(p-&gt;key));
      ++p;
    }

    return ary;

  }
#endif


  /*
   * enumerate over selectors as key,value pairs
   *
   * call-seq:
   *   epr.each { |key,value| ... }
   *
   */
  void each() {
    int i;
    key_value_t *p = NULL;
    VALUE value, ary;
    p = $self-&gt;refparams.selectorset.selectors;
    for (i = 0; i &lt; $self-&gt;refparams.selectorset.count; i++) {
      ary = rb_ary_new2(2);
      rb_ary_store(ary, 0, SWIG_FromCharPtr(p-&gt;key));
      if (p-&gt;type == 0) {
        value = SWIG_FromCharPtr(p-&gt;v.text);
      } else {
        value = SWIG_NewPointerObj((void*) p-&gt;v.epr, SWIGTYPE_p_epr_t, 0);
      }
      rb_ary_store(ary, 1, value);
      rb_yield(ary);
      p++;
    }
  }


  %newobject classname;
  /*
   * Classname of EPR
   */
  char *classname(void) {
    return uri_classname($self-&gt;refparams.uri);
  }
 
  %newobject namespace;
  /*
   * Namespace of EPR
   */
  char *namespace(void) {
    char *classname;
    int classnamelen, namespacelen;
    const char *prefix;
    const char *uri;

    /* try to get namespace from selectors (WS-Management style) */
    char *ns = get_cimnamespace_from_selectorset(&amp;($self-&gt;refparams.selectorset));
    if (ns) {
      return strdup(ns);
    }
    /* WMI style? - extract namespace from uri */

    uri = $self-&gt;refparams.uri;
    prefix = epr_prefix(uri);
    if (prefix == NULL) {
      return NULL; /* bad classname in URI */
    }
    classname = uri_classname(uri);
    if (classname == NULL)
      return NULL; /* bad URI */
    classnamelen = strlen(classname);
    free(classname);
    namespacelen = strlen(uri) - classnamelen - strlen(prefix) - 2; /* drop enclosing slashes */
    if (namespacelen &lt;= 0)
      return strdup(&quot;&quot;);
    /* copy after prefix slash (+ 1) */
    return strndup(uri + strlen(prefix) + 1, namespacelen);
  }
  
  %newobject prefix;
  /*
   * Prefix of EPR
   */
  char *prefix(void) {
    return epr_prefix($self-&gt;refparams.uri);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

