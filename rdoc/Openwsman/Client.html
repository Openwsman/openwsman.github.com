<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Openwsman::Client - Openwsman - WS-Management for all</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link">Object
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-i-build_envelope_from_response">#build_envelope_from_response</a>
    <li ><a href="#method-i-delete">#delete</a>
    <li ><a href="#method-i-delete_from_epr">#delete_from_epr</a>
    <li ><a href="#method-i-dumpfile-3D">#dumpfile=</a>
    <li ><a href="#method-i-encoding">#encoding</a>
    <li ><a href="#method-i-encoding-3D">#encoding=</a>
    <li ><a href="#method-i-enumerate">#enumerate</a>
    <li ><a href="#method-i-fault_string">#fault_string</a>
    <li ><a href="#method-i-get">#get</a>
    <li ><a href="#method-i-get_from_epr">#get_from_epr</a>
    <li ><a href="#method-i-host">#host</a>
    <li ><a href="#method-i-identify">#identify</a>
    <li ><a href="#method-i-last_error">#last_error</a>
    <li ><a href="#method-i-password">#password</a>
    <li ><a href="#method-i-path">#path</a>
    <li ><a href="#method-i-port">#port</a>
    <li ><a href="#method-i-pull">#pull</a>
    <li ><a href="#method-i-release">#release</a>
    <li ><a href="#method-i-renew">#renew</a>
    <li ><a href="#method-i-response_code">#response_code</a>
    <li ><a href="#method-i-scheme">#scheme</a>
    <li ><a href="#method-i-send_request">#send_request</a>
    <li ><a href="#method-i-subscribe">#subscribe</a>
    <li ><a href="#method-i-transport">#transport</a>
    <li ><a href="#method-i-unsubscribe">#unsubscribe</a>
    <li ><a href="#method-i-user">#user</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Openwsman::Client">
  <h1 id="class-Openwsman::Client" class="class">
    class Openwsman::Client
  </h1>

  <section class="description">
    
<p>Instances of <a href="Client.html"><code>Client</code></a> represent a connection to a client used for sending WS-Management operation requests.</p>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            new(uri)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(host, port, path, scheme, username, password)
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(&quot;http://user:pass@host.domain.com:1234/path&quot;)
          </span>
        </div>
        <div class="method-heading">
          <span class="method-callseq">
            new(&quot;host.domain.com&quot;, 1234, &quot;/path&quot;, &quot;http&quot;, &quot;user&quot;, &quot;pass&quot;)
          </span>
        </div>

        <div class="method-description">
          <p>Create a client connection.</p>

<p>There are two ways to connect to a client, either by specifying a URL or by passing all client parameters separately</p>

          <div class="method-source-code" id="new-source">
            <pre>( const char *uri ) {
    struct _WsManClient *client = wsmc_create_from_uri( uri );
    if (client == NULL)
      SWIG_exception( SWIG_ValueError, &quot;Can&#39;t create Openwsman::Client from given URI&quot; );

    return client;
  }

  /*
   * :nodoc:
   */
  _WsManClient(const char *hostname,
              const int port, const char *path,
              const char *scheme,
              const char *username,
              const char *password) {
    struct _WsManClient *client = wsmc_create( hostname, port, path, scheme, username, password );
    if (client == NULL)
      SWIG_exception( SWIG_ValueError, &quot;Can&#39;t create Openwsman::Client from given values&quot; );

    return client;
  }

  /* destructor */
  ~_WsManClient() {
    wsmc_release( $self );
  }

  /* set dumpfile */

  %rename( &quot;dumpfile=&quot; ) set_dumpfile( FILE *f );


  /*
   * Set the dumpfile (for debugging) to dump xml requests
   *
   * call-seq:
   *  client.dumpfile = File.open(...)
   *
   */
  void set_dumpfile( FILE *f ) {
    wsmc_set_dumpfile( $self, f );
  }

  /*
   * Response code of the last request (HTTP response code)
   *
   * call-seq:
   *  client.reponse_code -&gt; Integer
   *
   */
  long response_code() {
    return wsmc_get_response_code( $self );
  }

  %newobject scheme;
  /*
   * String representation of the transport scheme
   *
   * call-seq:
   *   client.scheme -&gt; String
   *
   */
  char *scheme() {
    return wsmc_get_scheme( $self );
  }

  %newobject host;
  /*
   * The host part of the client URL
   *
   */
  char *host() {
    return wsmc_get_hostname( $self );
  }

  /*
   * The TCP port used in the connection
   *
   */
  int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-build_envelope_from_response" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            build_envelope_from_response() &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Build envelope from response</p>

          <div class="method-source-code" id="build_envelope_from_response-source">
            <pre>WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete(options, uri) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Transport</p>

<p>delete: Delete a resource</p>

          <div class="method-source-code" id="delete-source">
            <pre>WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_from_epr" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            delete_from_epr(options, end_point_reference) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Delete</p>

<p><a href="Client.html#method-i-delete_from_epr"><code>delete_from_epr</code></a>: Remove a resource via an endpoint reference</p>

          <div class="method-source-code" id="delete_from_epr-source">
            <pre>WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-dumpfile-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            dumpfile = File.open(...)
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set the dumpfile (for debugging) to dump xml requests</p>

          <div class="method-source-code" id="dumpfile-3D-source">
            <pre>void set_dumpfile( FILE *f ) {
    wsmc_set_dumpfile( $self, f );
  }

  /*
   * Response code of the last request (HTTP response code)
   *
   * call-seq:
   *  client.reponse_code -&gt; Integer
   *
   */
  long response_code() {
    return wsmc_get_response_code( $self );
  }

  %newobject scheme;
  /*
   * String representation of the transport scheme
   *
   * call-seq:
   *   client.scheme -&gt; String
   *
   */
  char *scheme() {
    return wsmc_get_scheme( $self );
  }

  %newobject host;
  /*
   * The host part of the client URL
   *
   */
  char *host() {
    return wsmc_get_hostname( $self );
  }

  /*
   * The TCP port used in the connection
   *
   */
  int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-encoding" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            encoding &rarr; &quot;utf-8&quot;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get client encoding</p>

          <div class="method-source-code" id="encoding-source">
            <pre>char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-encoding-3D" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            encoding = &quot;utf-8&quot;
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Set client encoding</p>

          <div class="method-source-code" id="encoding-3D-source">
            <pre>void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-enumerate" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            enumerate(options, filter, uri) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Enumerate</p>

<p>enumerate: List resources</p>

<p>It is highly recommended to do an optimized enumeration by setting the client options</p>

<pre class="ruby"><span class="ruby-identifier">options</span>.<span class="ruby-identifier">flags</span> = <span class="ruby-constant">Openwsman</span><span class="ruby-operator">::</span><span class="ruby-constant">FLAG_ENUMERATION_OPTIMIZATION</span>
<span class="ruby-identifier">options</span>.<span class="ruby-identifier">max_elements</span> = <span class="ruby-value">999</span>
</pre>

<p>to get the enumeration result as part of the http request.</p>

<p>Otherwise separate pull requests are needed resulting in extra round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically affecting performance.</p>

          <div class="method-source-code" id="enumerate-source">
            <pre>WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-fault_string" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            fault_string &rarr; String
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get a string representation of the last fault</p>

          <div class="method-source-code" id="fault_string-source">
            <pre>char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            get(options, uri) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Transport</p>

<p>get: Get a resource</p>

          <div class="method-source-code" id="get-source">
            <pre>WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_from_epr" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            get_from_epr(options, end_point_reference) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Get</p>

<p><a href="Client.html#method-i-get_from_epr"><code>get_from_epr</code></a>: Get a resource via an endpoint reference</p>

          <div class="method-source-code" id="get_from_epr-source">
            <pre>WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-host" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">host</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The host part of the client URL</p>

          <div class="method-source-code" id="host-source">
            <pre>char *host() {
    return wsmc_get_hostname( $self );
  }

  /*
   * The TCP port used in the connection
   *
   */
  int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-identify" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            identify(options) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Identify</p>

<p>identify: Sends an identify request</p>

          <div class="method-source-code" id="identify-source">
            <pre>WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-last_error" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            last_error &rarr; Integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Get a numeric representation of the last fault</p>

          <div class="method-source-code" id="last_error-source">
            <pre>int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-password" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">password</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The password used for authentication</p>

          <div class="method-source-code" id="password-source">
            <pre>char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-path" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">path</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The path of the clien URL</p>

          <div class="method-source-code" id="path-source">
            <pre>char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-port" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">port</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The TCP port used in the connection</p>

          <div class="method-source-code" id="port-source">
            <pre>int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-pull" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            pull(options, filter, uri, context) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Transport</p>

<p>pull: Get resources from enumeration context</p>

          <div class="method-source-code" id="pull-source">
            <pre>WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-release" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            release(options, uri, context) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Release</p>

<p>release: Release enumeration context</p>

          <div class="method-source-code" id="release-source">
            <pre>WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-renew" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            renew(options, uri, identifier) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Eventing</p>

<p>renew: Renew a subscription</p>

          <div class="method-source-code" id="renew-source">
            <pre>WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-response_code" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            reponse_code &rarr; Integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Response code of the last request (HTTP response code)</p>

          <div class="method-source-code" id="response_code-source">
            <pre>long response_code() {
    return wsmc_get_response_code( $self );
  }

  %newobject scheme;
  /*
   * String representation of the transport scheme
   *
   * call-seq:
   *   client.scheme -&gt; String
   *
   */
  char *scheme() {
    return wsmc_get_scheme( $self );
  }

  %newobject host;
  /*
   * The host part of the client URL
   *
   */
  char *host() {
    return wsmc_get_hostname( $self );
  }

  /*
   * The TCP port used in the connection
   *
   */
  int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-scheme" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            scheme &rarr; String
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>String representation of the transport scheme</p>

          <div class="method-source-code" id="scheme-source">
            <pre>char *scheme() {
    return wsmc_get_scheme( $self );
  }

  %newobject host;
  /*
   * The host part of the client URL
   *
   */
  char *host() {
    return wsmc_get_hostname( $self );
  }

  /*
   * The TCP port used in the connection
   *
   */
  int port() {
    return wsmc_get_port( $self );
  }

  %newobject path;
  /*
   * The path of the clien URL
   *
   */
  char *path() {
    return wsmc_get_path( $self );
  }

  %newobject user;
  /*
   * The user name used for authentication
   *
   */
  char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-send_request" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) &rarr; Integer
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>Send a (raw) SOAP request to the client</p>

          <div class="method-source-code" id="send_request-source">
            <pre>int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-subscribe" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            subscribe(options, filter, uri) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Eventing</p>

<p>subscribe: Subscribe a listener to events</p>

          <div class="method-source-code" id="subscribe-source">
            <pre>WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-transport" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">transport</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The Transport instance associated to the client</p>

          <div class="method-source-code" id="transport-source">
            <pre>WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unsubscribe" class="method-detail ">
        <div class="method-heading">
          <span class="method-callseq">
            unsubscribe(options, filter, uri, identifier) &rarr; XmlDoc
          </span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>WS-Eventing</p>

<p>unsubscribe: Remove a listener from events</p>

          <div class="method-source-code" id="unsubscribe-source">
            <pre>WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-user" class="method-detail ">
        <div class="method-heading">
          <span class="method-name">user</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>

        <div class="method-description">
          <p>The user name used for authentication</p>

          <div class="method-source-code" id="user-source">
            <pre>char *user() {
    return wsmc_get_user( $self );
  }

  %newobject password;
  /*
   * The password used for authentication
   *
   */
  char *password() {
    return wsmc_get_password( $self );
  }
  
  /*
   * The Transport instance associated to the client
   */
  WsManTransport *transport() {
    wsmc_transport_init($self, NULL);
    wsmc_transport_set_auth_request_func( $self, auth_request_callback );

    return (WsManTransport *)$self;
  }

  /*
   * Send a (raw) SOAP request to the client
   *
   * call-seq:
   *   client.send_request(XmlDoc.new(&quot;&lt;xml ...&gt;...&lt;/xml&gt;&quot;)) -&gt; Integer
   *
   */
  int send_request(WsXmlDocH request) {
    return wsman_send_request($self, request);
  }

  /*
   * Build envelope from response
   *
   * call-seq:
   *   client.build_envelope_from_response() -&gt; XmlDoc
   *
   */
  WsXmlDocH build_envelope_from_response() {
    return wsmc_build_envelope_from_response($self);
  }

  /*
   * Get client encoding
   *
   * call-seq:
   *   client.encoding -&gt; &quot;utf-8&quot;
   *
   */
  char *encoding() {
    return wsmc_get_encoding($self);
  }
  

  %rename( &quot;encoding=&quot; ) set_encoding( const char *encoding );

  /*
   * Set client encoding
   *
   * call-seq:
   *   client.encoding = &quot;utf-8&quot;
   *
   */
  void set_encoding(const char *encoding) {
    wsmc_set_encoding($self, encoding);
  }

/*-----------------------------------------------------------------*/
/* actions */

  /*
   * WS-Identify
   *
   * identify: Sends an identify request
   *
   * call-seq:
   *   client.identify(options) -&gt; XmlDoc
   *
   */
  WsXmlDocH identify( client_opt_t *options ) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_identify_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_identify( $self, options );
#endif
  }
  
  /*
   * WS-Get
   *
   * get_from_epr: Get a resource via an endpoint reference
   *
   * call-seq:
   *   client.get_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH get_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Delete
   *
   * delete_from_epr: Remove a resource via an endpoint reference
   *
   * call-seq:
   *   client.delete_from_epr(options, end_point_reference) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete_from_epr( client_opt_t *options , epr_t *epr) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.epr = epr;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_from_epr_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete_from_epr( $self, epr, options);
#endif
  }

  /*
   * WS-Enumerate
   *
   * enumerate: List resources
   *
   * It is highly recommended to do an optimized enumeration by
   * setting the client options
   *   options.flags = Openwsman::FLAG_ENUMERATION_OPTIMIZATION
   *   options.max_elements = 999
   * to get the enumeration result as part of the http request.
   *
   * Otherwise separate pull requests are needed resulting in extra
   * round-trips (client -&gt; wsman -&gt; cimom &amp; back), dramatically
   * affecting performance.
   *
   * call-seq:
   *   client.enumerate(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH enumerate( client_opt_t *options , filter_t *filter, char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_enumerate_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_enumerate( $self, resource_uri, options, filter);
#endif
  }

  /*
   * WS-Transport
   *
   * pull: Get resources from enumeration context
   *
   * call-seq:
   *   client.pull(options, filter, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH pull( client_opt_t *options , filter_t *filter, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_pull_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_pull( $self, resource_uri, options, filter, context);
#endif
  }

  /*
   * WS-Create
   *
   * create: Create a resource
   *
   * call-seq:
   *   client.create(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH create( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_create_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_create_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Transport
   *
   * put: Change a resource
   *
   * call-seq:
   *   client.put(options, uri, xml, xml.size, &quot;utf-8&quot;) -&gt; XmlDoc
   *
   */
  WsXmlDocH put( client_opt_t *options, const char *resource_uri, const char *data, size_t size, const char *encoding = &quot;utf-8&quot;) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.data = data;
    args.size = size;
    args.encoding = encoding;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_put_fromtext_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_put_fromtext( $self, resource_uri, options, data, size, encoding);
#endif
  }

  /*
   * WS-Release
   *
   * release: Release enumeration context
   *
   * call-seq:
   *   client.release(options, uri, context) -&gt; XmlDoc
   *
   */
  WsXmlDocH release( client_opt_t *options, const char *resource_uri, const char *context) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.context = context;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_release_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_release( $self, resource_uri, options, context);
#endif
  }

  /*
   * WS-Transport
   *
   * get: Get a resource
   *
   * call-seq:
   *   client.get(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH get( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_get_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_get( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Transport
   *
   * delete: Delete a resource
   *
   * call-seq:
   *   client.delete(options, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH delete( client_opt_t *options, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_delete_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_delete( $self, resource_uri, options);
#endif
  }

  /*
   * WS-Invoke
   *
   * invoke: Invoke a resource function
   *
   * call-seq:
   *   client.invoke(options, uri, &quot;method-name&quot;) -&gt; XmlDoc
   *   client.invoke(options, uri, &quot;method-name&quot;, xml_doc) -&gt; XmlDoc
   *
   */
  WsXmlDocH invoke( client_opt_t *options, const char *resource_uri, const char *method, WsXmlDocH data = NULL) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.method = method;
    args.method_args = data;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_invoke_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_invoke( $self, resource_uri, options, method, data);
#endif
  }

  /*
   * WS-Eventing
   *
   * subscribe: Subscribe a listener to events
   *
   * call-seq:
   *   client.subscribe(options, filter, uri) -&gt; XmlDoc
   *
   */
  WsXmlDocH subscribe(client_opt_t *options, filter_t *filter, const char *resource_uri) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_subscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_subscribe($self,  resource_uri, options, filter);
#endif
  }

  /*
   * WS-Eventing
   *
   * unsubscribe: Remove a listener from events
   *
   * call-seq:
   *   client.unsubscribe(options, filter, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH unsubscribe(client_opt_t *options, filter_t *filter, const char *resource_uri, const char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.filter = filter;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_unsubscribe_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_unsubscribe($self, resource_uri, options, identifier);
#endif
  }

  /*
   * WS-Eventing
   *
   * renew: Renew a subscription
   *
   * call-seq:
   *   client.renew(options, uri, identifier) -&gt; XmlDoc
   *
   */
  WsXmlDocH renew(client_opt_t *options , char *resource_uri, char *identifier) {
#if RUBY_VERSION &gt; 18 /* YARV */
    wsmc_action_args_t args;
    args.client = $self;
    args.options = options;
    args.resource_uri = resource_uri;
    args.identifier = identifier;
#if RUBY_VERSION &gt; 20 /* New threading model */
    return (WsXmlDocH)rb_thread_call_without_gvl((void * (*)(void *))ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#else
    return (WsXmlDocH)rb_thread_blocking_region((rb_blocking_function_t*)ruby_renew_thread, &amp;args, RUBY_UBF_IO, 0);
#endif
#else
    return wsmc_action_renew($self, resource_uri, options, identifier);
#endif
  }

  /*
   * Get a string representation of the last fault
   *
   * call-seq:
   *   client.fault_string -&gt; String
   *
   */
  char *fault_string() {
    return wsmc_get_fault_string($self);
  }
  
  /*
   * Get a numeric representation of the last fault
   *
   * call-seq:
   *   client.last_error -&gt; Integer
   *
   */
   int last_error() {
     return wsmc_get_last_error($self);
   }
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

